/**
 * Copyright lizhaolong(https://github.com/Super-long)
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *  http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

/* Code comments are all encoded in UTF-8.*/

package Flake

import (
	"log"
	"math/rand"
	"net"
	"time"

	"github.com/sony/sonyflake"
)

/*
 * @brief: Generate a globally unique ID using the snowflake algorithm
 * @notes: Using 0 as the initial value at the protocol layer, it is obvious that the UUID generated by flake cannot be zero, because the timestamp has already been set.
 */
// ps: The reason for the problem in the test code is very simple, it is because the timestamps may be the same, there is actually no good way to solve this, manually configuring the test code is the most convenient.
func GetSonyflake() uint64 {

	setting := sonyflake.Settings{}
	// Set the start time to maximize the effective usage time of the algorithm
	setting.StartTime = time.Date(2020, 10, 24, 10, 24, 10, 24, time.UTC)
	setting.MachineID = GetMachineIdentification
	flake := sonyflake.NewSonyflake(setting)
	id, err := flake.NextID()
	if err != nil {
		log.Fatalf("flake.NextID() failed with %s\n", err)
	}
	return id
}

/*
 * @brief: Generate a 16-bit machine identifier based on the local network card MAC address and a random number
 * @notes: The default machine identifier generation function of Sony's snowflake algorithm library uses the intranet IP, because the client calls this function, and now basically uses NET technology, it is very likely to cause duplication, so it is necessary to modify the machine identifier generation function.
 * Currently, the plan is to use the last digit of the first number of each of the six items of the MAC address for the first 6 bits, and the last 10 bits are random values. Because there is also a timestamp bit, this can maximize the guarantee that a unique ID will not appear globally, but it is still possible.
 * And because the machine identifier generated by the same host is definitely the same, the test code still has to manually change the UUID.
 */
func GetMachineIdentification() (uint16, error) {
	interfaces, err := net.Interfaces()
	if err != nil {
		log.Println("ERROR : Error reading network interface. " + err.Error())
		// Need to check the error first
		return 0, nil
	}
	var res uint16 = 0
	// 8c:16:45:36:2 e:c 4
	// 1  3  6  9  12  15
	var indexes = [6]uint32{0, 3, 6, 9, 12, 15}

	for _, inter := range interfaces {
		mac := inter.HardwareAddr.String() // Get the local MAC address, 17-character string
		// fmt.Println("DEBUG : MAC = ", mac)
		if len(mac) == 17 { // 8c:16:45:36:2e:c4
			for i := 0; i < 6; i++ {
				var temp uint8 = 0
				temp = mac[indexes[i]] & 1 // Take the last bit
				res ^= uint16(temp << i)
			}
		}
	}

	// Generate a random number between 0 and 1023
	rand.Seed(time.Now().Unix()) // Use time as the random number seed
	high := rand.Intn(1023)      // Pseudo-random number

	res |= uint16(high << 6)
	// log.Printf("DEBUG : machine identification(%b)\n", res)
	return res, nil
}
