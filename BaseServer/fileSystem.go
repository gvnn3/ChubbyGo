/**
 * Copyright lizhaolong(https://github.com/Super-long)
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *  http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

/* Code comments are all encoded in UTF-8.*/

package BaseServer

import (
	"crypto/sha1"
	"fmt"
	"log"
)

// ps: All operations in the file system are based on locks

const (
	Directory     = iota
	TemporaryFile // Temporary nodes will be automatically deleted when no client opens them
	PermanentFile
)

const (
	NotLock = iota
	ReadLock
	WriteLock
)

type ChubbyGoFileSystemError int8

const (
	PathError = iota
	CheckSumError
	InstanceSeqError
	DoesNotSupportRecursiveDeletion
	CannotDeleteFilesWithZeroReferenceCount
	LockTypeError
	ReleaseBeforeAcquire
	OnlyDirectoriesCanCreateFiles
	TokenSeqError
	FileNameError
)

func (err ChubbyGoFileSystemError) Error() string {
	var ans string
	switch err {
	case PathError:
		ans = "Filename and directory have the same name."
	case CheckSumError:
		ans = "Client sent an incorrect CheckSum."
	case InstanceSeqError:
		ans = "Client sent an incorrect InstanceSeq."
	case DoesNotSupportRecursiveDeletion:
		ans = "Does not support recursive deletion, there are still files in this directory."
	case CannotDeleteFilesWithZeroReferenceCount:
		ans = "Deleting a file with a reference count of zero."
	case LockTypeError:
		ans = "Lock type error."
	case ReleaseBeforeAcquire:
		ans = "The lock being released has not been locked."
	case OnlyDirectoriesCanCreateFiles:
		ans = "Only directories can create files."
	case TokenSeqError:
		ans = "Client sent an incorrect TokenSeq."
	case FileNameError:
		ans = "The inserted file has disallowed characters."
	}
	return ans
}

type FileSystemNode struct {
	// Parameters to be passed in when creating a new file under this file
	fileType   int       // Three types of files; link files are not supported
	readACLs   *[]uint64 // Read access control lists
	writeACLs  *[]uint64 // Write access control lists, write permission is required for any type of lock request
	modifyACLs *[]uint64 // List of permissions to modify this node's ACL
	fileName   string    // The name of this file

	instanceSeq uint64 // Instance number: greater than the instance number of any previous node with the same name
	tokenSeq    uint64 // Lock generation number: this value increases when the node's lock transitions from idle to held. Used to cancel the previous seq's permissions when the lock times out
	aCLsSeq     uint64 // ACL generation number: this value increases when writing the ACL name of the node. // Currently not understood what it is used for

	// Originally wanted to add the address of FileSystemNode, but the stack of go will change, so gave up this idea
	// Because the instanceSeq will not change during the file descriptor period, but it will change overall;
	// It seems that the checksum is not necessarily a checksum of the entire structure, as long as the randomness is guaranteed; this statement is very wrong, because each node will receive the same checksum, if multiple nodes generate different ones, it will cause the leader to succeed and other nodes to fail
	checksum uint64 // Return to the client to construct a file descriptor that is difficult to forge

	OpenReferenceCount     uint64 // Open reference count, mainly used for folders, can be understood as file descriptors are meaningless, files are meaningful for LockType
	nowLockType            int    // Current lock type, there are three situations
	readLockReferenceCount uint64 // Read lock reference count

	// The provided lock is advisory, that is, you can perform get and put operations on the file content without locking, but only string storage is provided, and the client can customize the protocol
	nowPath       string                     // Mark the current path, used to get the value stored in this file from the raft log dictionary
	nextNameCache map[string]uint64          // Actually the InstanceSeq of the next level; this field is invalid when the node is a file
	next          map[string]*FileSystemNode // Using map can find all file nodes of the next level faster and orderly; this field is invalid when the node is a file
}

/*
 * @brief: Generate a new CheckSum based on FileSystemNode; actually just ensure randomness; is it necessary to generate such a number with great effort? Although it is not used much
 * @notes: Completely wrong; we need a checksum generated by the file content, so that it can be executed successfully on different nodes
 */
/*func (Fsn *FileSystemNode) makeCheckSum() uint64 {
	var res uint64

	// step1: Take the value of the object address
	// AddressValue can get the specific value of the 64-bit integer of the object address
	p := reflect.ValueOf(unsafe.Pointer(&Fsn))
	// Because the low bit of the entire address starts with 0Xc, one bit can be deduced, and many bits can be deduced when the program is small, so we use the right 32 bits
	// var AddressValue uint64 = uint64(p.Pointer())
	res = uint64(p.Pointer())

	// step2: Get the value of instanceSeq, temporarily set the last ten bits
	res += Fsn.instanceSeq << 32

	// step3: Randomly generate a value
	rand.Seed(time.Now().Unix()) // Use time as the random number seed
	high := rand.Intn(2<<22 - 1) // Pseudo-random number

	res += uint64(high) << 42

	// [63  42][41  32][31  0]
	// [Random number][instanceSeq][address]
	return res
}*/

/*
 * @notes: Use instanceSeq, nowPath, len(next), len(nextNameCache) as parameters to generate a 64-bit checksum, there is no need to use CRC, MD5,
 * as long as the same input can get the same output; this may cause the checksum of multiple open files to be the same
 * Obviously the minimum value of instanceSeq is 1, and the checksum cannot be 0, so ClientInstanceSeq and ClientInstanceSeq can use 0 as an invalid value
 */
func (Fsn *FileSystemNode) makeCheckSum() uint64 {
	// Generate a 20-bit string, each bit is a hexadecimal number
	hash := sha1.New()
	hash.Write([]byte(Fsn.nowPath))
	sha1Res := hash.Sum(nil)

	var res uint64 = 0

	for i := 0; i < 14; i++ {
		res = res | (uint64(sha1Res[i]) << (4 * i))
	}

	//[63,56][55,0]

	res = res | Fsn.instanceSeq<<57

	res = res | uint64(len(Fsn.next)<<59)

	res = res | uint64(len(Fsn.nextNameCache)<<61)

	return res
}

/*
 * @brief: Type: the type of file to be created; name: file name; the following are the initial operation permissions of the file
 * @return: Return true if inserted correctly; otherwise return false
 * @notes: When the file is created, it is opened by default, that is, the reference count is 1, and the client can insert the file to prove that the client's InstanceSeq is the directory's
 */
func (Fsn *FileSystemNode) Insert(InstanceSeq uint64, Type int, name string, ReadAcl *[]uint64, WriteAcl *[]uint64, ModifyAcl *[]uint64) (uint64, uint64, error) {
	if InstanceSeq < Fsn.instanceSeq {
		return 0, 0, ChubbyGoFileSystemError(InstanceSeqError)
	}

	if Fsn.fileType != Directory { // Only directories are allowed to create new files
		return 0, 0, ChubbyGoFileSystemError(OnlyDirectoriesCanCreateFiles)
	}

	// The file name can only not contain '/' and ' ', and the url judgment needs to be modified here later
	bytesFileName := str2sbyte(name)
	bytesLength := len(bytesFileName)
	for i := 0; i < bytesLength; i++ {
		if bytesFileName[i] == '/' || bytesFileName[i] == ' ' {
			return 0, 0, ChubbyGoFileSystemError(FileNameError)
		}
	}

	// Directories and files cannot have the same name
	_, IsExist := Fsn.next[name]
	if IsExist { // Fsn contains a file with the same name as this file
		return 0, 0, ChubbyGoFileSystemError(PathError)
	}

	NewNode := &FileSystemNode{}

	NewNode.fileType = Type
	if Type == Directory {
		NewNode.next = make(map[string]*FileSystemNode)
		NewNode.nextNameCache = make(map[string]uint64)
	}

	NewNode.fileName = name
	NewNode.readACLs = ReadAcl
	NewNode.writeACLs = WriteAcl
	NewNode.modifyACLs = ModifyAcl

	// The initial value is set to 2, with 0 as the invalid value and 1 as the delete value
	if Seq, ok := Fsn.nextNameCache[name]; ok {
		NewNode.instanceSeq = Seq // Use it directly when using it, and increment it when deleting
	} else {
		NewNode.instanceSeq = 2
		Fsn.nextNameCache[name] = 2
	}
	NewNode.tokenSeq = 2 // Increment before use, which means the minimum valid value of TockenSeq is 2
	NewNode.aCLsSeq = 0
	NewNode.checksum = NewNode.makeCheckSum()

	NewNode.nowLockType = NotLock
	NewNode.readLockReferenceCount = 0
	// Need to ensure uniqueness in each Cell
	NewNode.nowPath = Fsn.nowPath + "/" + name
	NewNode.OpenReferenceCount = 1
	Fsn.next[name] = NewNode

	RootFileOperation.pathToFileSystemNodePointer[NewNode.nowPath] = NewNode

	return NewNode.instanceSeq, NewNode.checksum, nil
}

/*
 * @param: InstanceSeq from the file descriptor, the name of the file to be deleted
 * @return: Return true if deleted successfully, otherwise return false
 * @notes: Need to check if the name exists;
 */
func (Fsn *FileSystemNode) Delete(InstanceSeq uint64, filename string, opType int, checkSum uint64) error {
	Node, IsExist := Fsn.next[filename]
	if !IsExist {
		log.Printf("INFO : %s/%s does not exist.\n", Fsn.nowPath, filename)
		return ChubbyGoFileSystemError(PathError)
	}

	if checkSum != Node.checksum {
		log.Printf("WARNING : A dangerous requirement, unmatched checksum, now(%d) -> client(%d).\n", Node.checksum, checkSum)
		return ChubbyGoFileSystemError(CheckSumError)
	}

	if InstanceSeq < Node.instanceSeq {
		log.Println("WARNING : Delete -> Request from a backward file descriptor!")
		return ChubbyGoFileSystemError(InstanceSeqError)
	}

	if Node.fileType == Directory && len(Fsn.next) != 0 {
		log.Println("WARNING : Recursive deletion of files is currently not allowed!")
		return ChubbyGoFileSystemError(DoesNotSupportRecursiveDeletion) // TODO Currently does not support this recursive deletion, because the files below may still hold locks, this will be discussed later
	}

	if Node.OpenReferenceCount <= 0 {
		log.Printf("ERROR : Delete a file(%s/%s) that referenceCount is zero.\n", Fsn.nowPath, filename)
		return ChubbyGoFileSystemError(CannotDeleteFilesWithZeroReferenceCount)
	}

	Node.OpenReferenceCount--

	// close: Only temporary files will be deleted when the reference count is zero, permanent files and directory files will not be deleted
	// delete: On the contrary
	if Node.OpenReferenceCount != 0 {
		return nil // delete succeeded, actually just removed the client's handle
	}

	// The name exists, the reference count is zero and is equal to the remote InstanceSeq, deletion can be performed
	if opType == Opdelete || Node.fileType == TemporaryFile { // This time it is a delete operation, if it is a close operation, permanent files and directories do not need to be deleted
		delete(Fsn.next, filename)
		Fsn.nextNameCache[filename]++ // The next time it is created, the INstanceSeq is different from the last time
	}

	// When the reference count of the file is zero, update the Checksum, that is, the handle obtained the next time it is opened is different, which can effectively prevent the client from forging the checkSum
	Node.checksum = Node.makeCheckSum()

	return nil
}

/*
 * @param: InstanceSeq from the file descriptor; the name of the file to be locked
 * @return: Return the current file's instanceSeq
 * @notes: Need to check if the name exists; the caller should first check the bool and then the seq
 */
func (Fsn *FileSystemNode) Acquire(InstanceSeq uint64, filename string, locktype int, checksum uint64) (uint64, error) {
	Node, IsExist := Fsn.next[filename]

	if !IsExist {
		log.Printf("INFO : %s/%s does not exist.\n", Fsn.nowPath, filename)
		return 0, ChubbyGoFileSystemError(PathError)
	}

	if checksum != Node.checksum {
		log.Printf("WARNING : A dangerous requirement, unmatched checksum, now(%d) -> client(%d).\n", checksum, Node.checksum)
		return 0, ChubbyGoFileSystemError(CheckSumError)
	}

	if InstanceSeq < Node.instanceSeq {
		log.Println("WARNING : Acquire -> Request from a backward file descriptor!")
		return 0, ChubbyGoFileSystemError(InstanceSeqError)
	}

	if Node.nowLockType == NotLock {
		if locktype == ReadLock {
			Node.readLockReferenceCount++
		}
		Node.nowLockType = locktype
	} else if Node.nowLockType == ReadLock && locktype == ReadLock {
		Node.readLockReferenceCount++
		return Node.tokenSeq, nil
	} else if Node.nowLockType == WriteLock { // Separate writing for clarity of all situations
		return 0, ChubbyGoFileSystemError(LockTypeError)
	} else { // now readLock, args writelock
		return 0, ChubbyGoFileSystemError(LockTypeError)
	}

	return Node.tokenSeq, nil // Directly return the current value, just add 1 in release
}

/*
 * @param: InstanceSeq from the file descriptor; the name of the file (lock) to be released
 * @return: Return true if released successfully, otherwise return false
 * @notes: Need to check if the name exists
 */
func (Fsn *FileSystemNode) Release(InstanceSeq uint64, filename string, Token uint64, checksum uint64) error {
	Node, IsExist := Fsn.next[filename]

	if !IsExist {
		log.Printf("INFO : %s/%s does not exist.\n", Fsn.nowPath, filename)
		return ChubbyGoFileSystemError(PathError)
	}

	if checksum != Node.checksum {
		log.Printf("WARNING : A dangerous requirement, unmatched checksum, now(%d) -> client(%d).\n", checksum, Node.checksum)
		return ChubbyGoFileSystemError(CheckSumError)
	}

	// Prevent lagging lock holders from releasing the lock held by other nodes
	if Token < Node.tokenSeq {
		log.Printf("WARNING : A lagging client wants to release file(%s) now(%d) node.clientSeq(%d).\n", Node.nowPath, Token, Node.tokenSeq)
		return ChubbyGoFileSystemError(TokenSeqError)
	}

	if InstanceSeq < Node.instanceSeq {
		log.Println("WARNING : Release -> Request from a backward file descriptor!")
		return ChubbyGoFileSystemError(InstanceSeqError)
	}

	if Node.nowLockType == NotLock {
		log.Println("WARNING : Error operation, release before acquire.")
		return ChubbyGoFileSystemError(ReleaseBeforeAcquire)
	} else if Node.nowLockType == ReadLock { // TODO But obviously this approach may cause write operations to starve
		if Node.readLockReferenceCount >= 1 {
			Node.readLockReferenceCount--
		} else { // Obviously this situation cannot occur
			log.Println("ERROR : Release -> Impossible situation.")
		}
	}

	if Node.readLockReferenceCount > 0 {
		return nil
	}

	// The current lock type is write lock or read lock reference count is 0, obviously the token will be incremented only after all read locks are released
	Node.tokenSeq++
	Node.nowLockType = NotLock

	return nil
}

/*
  - @param: InstanceSeq from the file descriptor; the name of the file to be locked
  - @return: Return the current file's instanceSeq
  - @notes: For a file, the client's open operation can check whether a file exists, if it exists, it will return a handle, otherwise it will return false;
    For a directory, open can get a handle to create a file;
*/
func (Fsn *FileSystemNode) Open(name string) (uint64, uint64) {
	// TODO Some permission checks should be done here, but I haven't thought about how to divide permissions yet

	// Open should return the instanceSeq of this file
	return Fsn.instanceSeq, Fsn.checksum
}

/*
 * @brief: Used to initialize the root directory of each Cell
 * @return: Return the entity of the root directory
 */
func InitRoot() *FileSystemNode {
	root := &FileSystemNode{}

	root.fileType = Directory
	// TODO How to adjust access control is a series of ACLs, this obviously needs to read the configuration file

	// After thinking about it, if the name of Chubby Cell is changed to the leaderID, it will be more troublesome to switch the master later, and it is not easy to call for the outside world
	// Because the ideal calling method is to have a DNS server, the client can use the name to get the address of this Cell
	// At this time, it is much more convenient to name it directly, TODO here still need to read a configuration file later
	//root.fileName = "ChubbyCell_" + strconv.Itoa(int(leaderID))
	root.fileName = "ChubbyCell_" + "lizhaolong"

	// The initial value of instanceseq and tokenseq is 2, with zero as the invalid value and 1 as the delete notification success value
	root.instanceSeq = 2
	root.tokenSeq = 2
	root.aCLsSeq = 0
	root.checksum = root.makeCheckSum()

	root.nowLockType = NotLock
	root.readLockReferenceCount = 0
	root.nowPath = "/ls/" + root.fileName // The root of all Cells is ls (lock server), which is a virtual root
	root.next = make(map[string]*FileSystemNode)
	root.nextNameCache = make(map[string]uint64)

	/*	log.Printf("Current path name : %s\n", root.nowPath)
		RootFileOperation.pathToFileSystemNodePointer[root.nowPath] = root*/

	return root
}

func (Fsn *FileSystemNode) CheckToken(token uint64, filename string) error {
	Node, IsExist := Fsn.next[filename]

	if !IsExist {
		log.Printf("INFO : %s/%s does not exist.\n", Fsn.nowPath, filename)
		return ChubbyGoFileSystemError(PathError)
	}

	if Node.tokenSeq == token {
		return nil
	} else {
		return ChubbyGoFileSystemError(TokenSeqError)
	}
}

/*
 * @brief: For debugging, display the names of all files in the current directory tree
 */
func RecursionDisplay(Fsn *FileSystemNode) {
	fmt.Println(Fsn.nowPath)
	for _, value := range Fsn.next {
		RecursionDisplay(value)
	}
}

/*
 * @brief: For debugging, output interval symbols
 */
func IntervalDisPlay() {
	fmt.Println("----------------------------------")
}
